# Training NestJS API Development

In this training I will show you how to create a REST API using NestJS.
I will go over performing CRUD operations in a database, authentication,
role-based authorization, file upload and much more.


# Table of contents
1. [Introduction](#introduction)
    1. [Installation](#installation)
    1. [Creating a new project](#creation)
    1. [What's inside the project](#inside)
        1. [The `main.ts` file](#main.ts)
        1. [What is a module? The `app.module.ts` file](#app.module.ts)
        1. [The `app.controller.ts` and `app.service.ts` files](#app.useless)
1. [Generating our first resource: Posts resource](#posts)
    1. [Basic scaffolding](#posts.scaffolding)
    1. [The `posts.module.ts` file](#posts.module)
    1. [What is a controller? The `posts.controller.ts` file](#posts.controller)
        1. [Defining `GET` routes](#posts.get)


# Introduction <a name="introduction"></a>

This chapter will cover the basics of NestJS


## NestJs CLI Installation <a name="installation"></a>

The first step is to install the nestjs cli, which is used to
create and run projects, and create resources inside your nestjs project.
We can do this by running: `npm install -g @nestjs/cli` inside the terminal.

This will install the cli globally, which means that you can run
nest cli commands in any folder using the `nest` command.


## Creating a new project <a name="creation"></a>

To create a new nest project you can simply execute `nest new project_name`
where project_name is the name of your project.. pretty self-explanatory.

The command will prompt you to choose which packet manager
you want to use `npm` or `yarn`, choose your favorite
(I will chose npm in this tutorial).


## What's inside the project <a name="inside"></a>

When you open the project folder you can see that nest generated
a basic scaffold for us inside the `src` folder, and also installed all
the npm packages we needed for our app. Nest also generates a `test`
folder where you can write tests for your projects, we will not focus
on them or any other test file generated by nest in this tutorial.

**Important!!!** Do not forget to include your `package-lock.json` in `.gitignore`.

Let's dive deeper inside the `src` folder.

```
src/
 |--app.controller.spec.ts #this is a test file, we do not care about it for now
 |--app.controller.ts
 |--app.module.ts
 |--app.service.ts
 |--main.ts
```

### The `main.ts` file <a name="main.ts"></a>

The entry point for every nest application is the `main.ts` file,
this is the file which is run when you start your app.

```typescript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
}
bootstrap();
```

As you can see, the only function declared inside it is responsible for
loading our application into memory (the `app` variable) and then declaring on what
port it should listen to. In the future, we will also declare/initiate other
packages or global components inside `main.ts`.

The next thing we should look into is the `AppModule`.

### The `app.module.ts` file <a name="app.module.ts"></a>

First of all, I should define what a resource is. In nest, broadly speaking,
a resource represents everything we need to interact with a table in the database.

For example, a `Post` resource could include:
  * routes for CRUD operations
  * a model which defines the `posts` table inside the database
  * components which communicate with the database
  * additional business logic

The module is one of the most important building blocks of any nest application.
You can think of it like a container which holds every piece of software
required by a resource to function properly. It does not implement any kind of
logic by itself, but it couples everything together.

```typescript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [],
  controllers: [AppController],
  providers: [AppService],
  exports: [AppService],
})
export class AppModule {}
```

In the module decorator you can pass a `ModuleMetadata` object, which has 4 fields
all of them being optional:
  * `imports: []` - you can import other modules in order to use functionalities of
  the imported modules
  * `controllers: []` - they define routes for your resources
  * `providers: []` - they define business logic and database communication
  * `exports: []` - if you want a provider defined in module `A` to be
  used in module `B` you must export the provider and import module `A`
  in module `B`

We will go more in depth into `controllers` and `providers` in the following chapters.

**Important!!!**

The `AppModule` is the root module of any nest application, this means that
`AppModule` is the first module loaded in memory and all other modules are loaded
only if they appear in the `imports: []` field of the `AppModule`.
So every module you create must be imported to `AppModule`.

### The `app.controller.ts` and `app.service.ts` files <a name="app.useless"></a>

In this tutorial, and most other projects, we will not use these files. The reason
for this is that `providers` and `controllers` are usually grouped together to offer
functionalities to a resource, but the `AppModule` is mostly a big container for our
application, it should not implement any kind of logic. There isn't any kind of rule
that prohibits defining `controllers` and `providers` for the `AppModule`, but I
usally avoid doing so.

For this reason I will delete `app.controller.ts` and `app.service.ts`, and
delete the correlated imports inside the `AppModule`.

# Generating our first resource: Posts resource <a name="posts"></a>

## Basic scaffolding <a name="posts.scaffolding"></a>

When you want to create a new resource, you usually need:
  * `module` - to link together all functionalities
  * `controller` - to define routes
  * `service` - to define business logic

The nest cli can generate all of this using the following commands:

```
~/project_name$ nest g module post
~/project_name$ nest g controller post
~/project_name$ nest g service post
```

It is important to run the commands in this order so that the cli tool can add the
controller and the service automatically to the module. The `nest g module post`
will also import the `PostModule` inside `AppModule`.

The commands will also create `.spec.ts` files used for testing, we will delete them.

The file structure should look something like this:

```
src/
 +--post/
 |  |--post.controller.ts
 |  |--post.module.ts
 |  |--post.service.ts
 |--app.module.ts
 |--main.ts
```

Let's check each file.

## The `post.module.ts` file <a name="posts.module"></a>

```typescript
import { Module } from '@nestjs/common';
import { PostController } from './post.controller';
import { PostService } from './post.service';

@Module({
  controllers: [PostController],
  providers: [PostService]
})
export class PostModule {}
```

As you can see the structure is similar to the `AppModule`, it adds the
generated controller to the controllers array, and the service to the
providers array.

You can have as many controllers and providers as you want inside a module.

<a name="posts.controller"></a>

## What is a controller? The `post.controller.ts` file

```typescript
import { Controller } from '@nestjs/common';

@Controller()
export class PostController {}
```

A controller is simply a class that is decorated with the `@Controller()` decorator.
The controller is responsible for declaring the routes through which you can
interact with the resource.

You can define a route by declaring a function which will be responsible for
handling the request and decorate the function with one of the HTTP Request
Method decorators (you will see what are those in a minute).

### Defining `GET` routes <a name="posts.get"></a>

You can define a `GET` route by defining a function and decorating it with a
`@Get()` decorator. Inside the parentheses you can pass a string which represents
the path for your route.

```typescript
import { Controller, Get } from '@nestjs/common';

@Controller()
export class PostController {
    @Get('posts') // or @Get('/posts') the first / can be omitted
    getPosts() {
        return "Handle GET /posts request";
    }
}
```

Now, when a `GET /posts` request will be received by the server it will call the
`getPosts()` method.

If you want to nest routes you can simply add slashes inside the path string like
so: `@Get('nested/path/to/wherever')`

#### Parameters

At some point you will need to handle parameters in your path to create dynamic
urls. You can define a parameter inside a path string by preceeding it with `:`.

```typescript
@Get('/posts/:id/:other_id')
getPostById(@Param() params) {
  return params.id + params.other_id;
}
```

In the route defined above, `id` and `other_id` are parameters. You can access
parameters using the `@Param()` decorator, which should be added to the method
signature. `params` is an object which contains all of the defined parameters.

If you need only one parameter, instead of working with the whole parameter
object, you can specify the parameter you want to retrieve inside the parentheses
of the `@Param()` decorator.

```typescript
@Get('/posts/:first_param/:second_param')
getPostById(
  @Param('first_param') only_the_first_param,
  @Param() all_params
) {
  return only_the_first_param +
         all_params.first_param
         all_params.second_param;
}
```

#### Query Parameters

You will also need to handle query parameters, you can access them using the
`@Query()` decorator, which works identical to the `@Param()` decorator.

```typescript
@Get('/posts')
getPostById(@Query() query) {
  return query.first_query +
         query.second_query +
         query.other_query;
}
```

For example, if the server would receive a request:

`GET /posts?first_query=ceva&second_query=altceva`

Then:
  * `query.first_query` will hold `'ceva'`
  * `query.second_query` will hold `'altceva'`
  * `query.other_query` will hold `undefined`
